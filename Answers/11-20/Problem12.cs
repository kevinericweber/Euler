using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Euler
{
    /* The sequence of triangle numbers is generated by adding the natural numbers.
     * So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
     * 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
     * Let us list the factors of the first seven triangle numbers:
     *  1: 1
     *  3: 1,3
     *  6: 1,2,3,6
     *  10: 1,2,5,10
     *  15: 1,3,5,15
     *  21: 1,3,7,21
     *  28: 1,2,4,7,14,28
     *  We can see that 28 is the first triangle number to have over five divisors.
     *  What is the value of the first triangle number to have over five hundred divisors?
     */
    class Problem12 : testableAnswer
    {


        public override string GetAnswer()
        {
            return GetAnswerForFactorCount(501).ToString();
        }

        private long GetAnswerForFactorCount(int factorCountRequired)
        {
            for (long triangleHeight = 1; triangleHeight < 1000000; triangleHeight++)
            {
                long triangleVolume = (triangleHeight * triangleHeight + triangleHeight) / 2;

                List<long> rawFactors = Shared.GetPrimeFactors(triangleVolume);
                List<Factor> factorGroups = GroupSameFactors(rawFactors);
                long totalFactorCount = GetTotalFactors(factorGroups);

                if (totalFactorCount >= factorCountRequired)
                    return triangleVolume;
            }

            throw new Exception("Answer not found.  Consider reworking for loop into while(), and/or changing type from long to something else");

        }

        private List<Factor> GroupSameFactors(List<long> rawList)
        {
            IEnumerable<long> nonOnes = rawList.Where(n => n != 1);
            IEnumerable<Factor> crossList = nonOnes.GroupBy(n => n).Select(x => new Factor(x.First(), x.Count()));
            
            return crossList.ToList();
        }

        // okay, the factors bit might need some explanation.
        // If you get the prime factors of 600, you'll get: 2, 2, 2, 3, 5, 5
        // From there, you can group them into:  2^3 * 3^1 * 5^2.
        // Once you've got that, its easy to get the total number of factors:
        // you just add one to each of the exponents, and add the exponents together
        //     (^3, ^1, ^2 becomes   4 * 2 * 3  = 24.  So 600 has 24 factors.)
        // It makes more sense if you try to systematically list all the factors:
        //      1, 2, 4, 8   [3^0 * 5^0] * {2^0, 2^1, 2^2, 2^3}
        //      3, 6, 12, 24    [3^1 * 5^0] * {2^0, 2^1, 2^2, 2^3}
        //      5, 10, 20, 40   [3^0 * 5^1] * {2^0, 2^1, 2^2, 2^3}
        //      15, 30, 60, 120 [3^1 * 5^1] * {2^0, 2^1, 2^2, 2^3}
        //      25, 50, 100, 200    [3^0 * 5^2] * {2^0, 2^1, 2^2, 2^3}
        //      75, 150, 300, 600   [3^1 * 5^2] * {2^0, 2^1, 2^2, 2^3}
        // ... if you tried to do this in a program, you'd loop from
        // {0-3} for the power of 2, {0-1} for the power of 3, and {0-2} for the power of 5
        // and end up with 4 * 2 * 3 iterations.
        private long GetTotalFactors(List<Factor> factors)
        {
            long retVal = 1;
            foreach(Factor f in factors)
            {
                retVal = retVal * (f.power + 1);
            }
            return retVal;
        }

        public override bool KnownTestPasses()
        {
            long expected = 28;
            long actual = GetAnswerForFactorCount(5);
            return (expected == actual);
        }

        public class Factor : IEqualityComparer<Factor>
        {
            public long factor;
            public long power;
            public Factor(long factor, long power)
            {
                this.factor = factor;
                this.power = power;
            }

            public bool Equals(Factor x, Factor y)
            {
                return x.factor == y.factor;
            }

            public int GetHashCode(Factor obj)
            {
                return this.factor.GetHashCode();
            }

            public override string ToString()
            {
                return factor + "^" + power;
            }
        }
    }
}
